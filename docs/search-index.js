var searchIndex = JSON.parse('{\
"confertus":{"doc":"","t":[0,0,0,0,0,5,5,5,5,5,5,5,5,5,3,12,11,11,12,12,11,11,11,11,11,11,3,17,3,6,3,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,12,12,11,11,11,11,11,11,11,12,11,11,12,12,11,11,12,12,12,11,11,11,11,11,11,12,11,11,11,11,12,12,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,12,11,11,8,8,8,8,16,8,10,11,11,11,10,10,10,10,10,10,10,11,11,10,10,10,10,10,10,10],"n":["commands","config","dynamic_vector","traits","utils","append_file","delete","flip","insert","rank","read_lines","select","wait_continue","write_file","Config","algo","borrow","borrow_mut","file_in","file_out","from","into","new","try_from","try_into","type_id","DynamicBitVector","HALF","Leaf","LeafValue","Node","access","access","apply","apply_bitop","bitsize_full","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","clone","clone","clone","clone_into","clone_into","clone_into","closest_neighbor_child","closest_neighbor_leaf","create","create_right_leaf","default","default","default","delete","delete","delete_unchecked","dotviz","dotviz","dotviz","eq","eq","eq","extend","extend_from","flip","flip","fmt","fmt","fmt","fmt","from","from","from","get_leaf_side","get_node_side","get_side","index","index","index_mut","index_mut","insert","insert","insert_unchecked","into","into","into","leafs","left","merge_away","ne","ne","ne","new","new","new","nodes","nums","nums","nums","nums","ones","ones","ones","parent","parent","prepend","push","push","push_unchecked","rank","rank","rank","rebalance","rebalance_no_child","replace_child_with","retrace","right","root","rotate_left","rotate_right","select","select","split_leaf","split_to_left","split_to_right","swap_remove_leaf","swap_remove_node","to_owned","to_owned","to_owned","to_string","try_from","try_from","try_from","try_into","try_into","try_into","type_id","type_id","type_id","update_left_values","value","values","values","BitSize","Dot","DynBitTree","DynBitVec","Intern","StaticBitVec","access","bitsize","bitsize_full","bitsize_used","child","delete","deletenode","dotviz","flip","insert","insertchild","is_empty","len","nums","ones","parent","rank","select","subtree_size","values"],"q":["confertus","","","","","confertus::commands","","","","","","","","","confertus::config","","","","","","","","","","","","confertus::dynamic_vector","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","confertus::traits","","","","","","","","","","","","","","","","","","","","","","","","",""],"d":["Module for parsing and building cli commands and args","Configuration for command line arguments","Actual implementation of dynamic bit vector with AVL Tree","Trait definitions, particularly for <code>StaticBitVec</code> and …","Module providing commonly used utility functions","Appending <code>text</code> to existing file with <code>filename</code> after …","","","","","Read large files line by line in Rust Efficient (cache) …","","","Write <code>text</code> to (non-) existing <code>filename</code>, overwriting it.","Configuration for command line arguments.","Which algorithm to use. Options are <code>bv</code> and <code>bp</code>","","","name of file with input commands","name of file to write results to","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","Create new Configuration instance based on arguments passed","","","","Implementation of Dynamic Bit Vector using self-balancing …","","Leaf element of <code>crate::DynamicBitVector</code>, particularly …","Container type used to contain bits in <code>Leaf</code>. Sensible …","Node element of <code>super::DynamicBitVector</code>. Contains …","Return value at position <code>index</code> of <code>DynamicBitVector</code>.","","Descend tree to position <code>index</code> and apply function <code>f</code> with …","Descend tree to position <code>index</code> and apply function <code>f</code> with …","","","","","","","","","","","","","","Try to return a Leaf that is the closest neighbor (left or …","Return closest immediately sequential neighbor to given …","Cunstructs a new <code>Leaf</code> with parent <code>parent</code>, container …","Create <code>Leaf</code> as right child of <code>node</code>, returns id of newly …","","","","","","Unchecked version of <code>Leaf::delete</code>","","","","","","","Extend LeafValue container with given values on given side …","Extend LeafValue container with values from other Leaf …","","","","","","","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Given Leaf <code>child</code>, return side on parent and parent index","Given Node <code>child</code>, return side on parent and parent index","Given some Child <code>child</code>, return side on parent and parent …","","","","","","","Unchecked version of <code>Leaf::insert</code>","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Vector containing <code>Leaf</code>, 24 bytes","left side subtree where <code>isize</code> is the index to child …","Try to find neighboring Leaf and merge into, or steal …","","","","Constructs new <code>DynamicBitVector</code> with empty root <code>Node</code>.","Constructs a new, empty <code>Leaf</code> with parent <code>parent</code>.","Constructs new, empty <code>Node</code>.","Vector containing <code>Node</code>, 24 bytes","","","number of bits used in <code>value</code>-container. Up to …","number of ‘filled’ bits on the left  subtree, 8 byte","","","number of ones on the left subtree, 8 byte","reference to parent <code>crate::Node</code> (8 byte)","index of parent Node, 8 bytes + 1bit","Prepend other values to existing values in LeafValue …","Append <code>bit</code> to the rightmost position in the rightmost <code>Leaf</code>.","Appends bit to the end of <code>self.value</code>.","Unchecked version of <code>Leaf::push</code>","","","difference of height between left and right subtree. Valid …","Rebalance tree to reestablish the rank difference …","Rebalance tree on <code>parent</code>, where highest node might not be …","Used when inserting a Node in place of a <code>crate::Leaf</code> or …","Retrace and update rank of parent until root (or until …","right side subtree where <code>isize</code> is the index to child …","index to root <code>Node</code>, 8 bytes","Left rotation of <code>Node</code>s <code>x</code> and <code>z</code>.","Right rotation of <code>Node</code>s <code>x</code> and <code>z</code>.","","","Split content of <code>leaf</code> in two, and replace location with …","Return full first/right half of <code>Leaf</code>-values, and remove …","Return full second/left half of <code>Leaf</code>-values, and remove …","Remove Leaf with given index <code>leaf</code>. Swaps with currently …","Remove Node with given index <code>node</code>. Swaps with currently …","","","","","","","","","","","","","","Recursively update parent values in case of left-child …","container for actual bit values (8-16 byte)","Return full internal container","","Trait to get instance bit size for different structs.","Visualize Tree-based structures with <code>graphviz</code> using the …","","Functions associated with dynamic bit vectors.","","Functions associated with static bit vectors. Not to be …","Access bit value at position <code>index</code>","Return total number of bits used by Type","Return total number of bits allocated by objects managed …","Return total number of used bits (fewer than allocated) by …","<code>child v i</code> write i-th child of v to output file","Remove bit value at position <code>index</code>","<code>deletenode v</code> delete node v","Return <code>dot</code> representation for graph visualization. Read …","Flip bit at position <code>index</code>, updates <code>ones</code> and <code>num</code> values …","Insert <code>bit</code> at position <code>index</code> in underlying container","<code>insertchild v i k</code> insert new <code>i</code>-th child of node <code>v</code> such …","If the Leaf has active values","Return used capacity of underlying container","Return used capacity of underlying container","Return number of on-bits in container","<code>parent v</code> write parent of v to output file","Returns number of <code>bit</code>-values up to <code>index</code> in container","Return index of <code>n</code>-th <code>bit</code>-value in container","<code>subtree size v</code> write subtree size of v (including v) to …","Return full internal container"],"i":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,2,3,2,2,2,2,3,4,2,3,4,2,3,4,2,3,4,2,2,3,2,2,3,4,2,3,3,2,3,4,2,3,4,3,3,2,3,2,2,3,4,2,3,4,2,2,2,2,2,2,2,2,3,3,2,3,4,2,4,2,2,3,4,2,3,4,2,2,3,3,4,2,3,4,3,4,3,2,3,3,2,3,4,2,2,4,2,4,2,2,2,2,3,2,3,3,2,2,2,3,4,2,2,3,4,2,3,4,2,3,4,2,3,2,3,0,0,0,0,5,0,5,6,6,6,7,8,7,9,8,8,7,8,8,8,5,7,5,5,7,5],"f":[null,null,null,null,null,[[["usize",0]],["result",4,[["str",0]]]],[[["dynamicbitvector",3],["vec",3,[["str",0]]]],["result",4,[["dynamicbitvector",3],["str",0]]]],[[["dynamicbitvector",3],["vec",3,[["str",0]]]],["result",4,[["dynamicbitvector",3],["str",0]]]],[[["dynamicbitvector",3],["vec",3,[["str",0]]]],["result",4,[["dynamicbitvector",3],["str",0]]]],[[["dynamicbitvector",3],["vec",3,[["str",0]]]]],[[],["result",6,[["lines",3,[["bufreader",3,[["file",3]]]]]]]],[[["dynamicbitvector",3],["vec",3,[["str",0]]]]],[[]],[[["str",0]],["result",6]],null,null,[[["",0]],["",0]],[[["",0]],["",0]],null,null,[[]],[[]],[[],["result",4,[["config",3],["str",0]]]],[[],["result",4]],[[],["result",4]],[[["",0]],["typeid",3]],null,null,null,null,null,[[["",0],["usize",0]],["bool",0]],[[["",0],["usize",0]],["bool",0]],[[["",0],["usize",0]]],[[["",0],["usize",0],["bool",0]]],[[["",0]],["usize",0]],[[["",0]],["",0]],[[["",0]],["",0]],[[["",0]],["",0]],[[["",0]],["",0]],[[["",0]],["",0]],[[["",0]],["",0]],[[["",0]],["dynamicbitvector",3]],[[["",0]],["leaf",3]],[[["",0]],["node",3]],[[["",0],["",0]]],[[["",0],["",0]]],[[["",0],["",0]]],[[["",0],["usize",0]],["option",4,[["either",4,[["isize",0],["isize",0]]]]]],[[["",0],["isize",0]],["option",4,[["either",4,[["isize",0],["isize",0]]]]]],[[["usize",0],["leafvalue",6],["u8",0]]],[[["",0],["usize",0]],["isize",0]],[[],["dynamicbitvector",3]],[[],["leaf",3]],[[],["node",3]],[[["",0],["usize",0]],["result",4,[["str",0]]]],[[["",0],["usize",0]],["result",4,[["str",0]]]],[[["",0],["usize",0]]],[[["",0],["isize",0]],["string",3]],[[["",0],["isize",0]],["string",3]],[[["",0],["isize",0]],["string",3]],[[["",0],["dynamicbitvector",3]],["bool",0]],[[["",0],["leaf",3]],["bool",0]],[[["",0],["node",3]],["bool",0]],[[["",0],["either",4,[["leafvalue",6],["leafvalue",6]]],["u8",0]]],[[["",0],["leaf",3]]],[[["",0],["usize",0]]],[[["",0],["usize",0]]],[[["",0],["formatter",3]],["result",6]],[[["",0],["formatter",3]],["result",6]],[[["",0],["formatter",3]],["result",6]],[[["",0],["formatter",3]],["result",6]],[[]],[[]],[[]],[[["",0],["isize",0]],["either",4,[["usize",0],["usize",0]]]],[[["",0],["usize",0]],["option",4,[["either",4,[["usize",0],["usize",0]]]]]],[[["",0],["isize",0]],["option",4,[["either",4,[["usize",0],["usize",0]]]]]],[[["",0],["isize",0]]],[[["",0],["usize",0]]],[[["",0],["isize",0]]],[[["",0],["usize",0]]],[[["",0],["usize",0],["bool",0]],["result",4,[["str",0]]]],[[["",0],["usize",0],["bool",0]],["result",4,[["str",0]]]],[[["",0],["usize",0],["bool",0]]],[[]],[[]],[[]],null,null,[[["",0],["isize",0]]],[[["",0],["dynamicbitvector",3]],["bool",0]],[[["",0],["leaf",3]],["bool",0]],[[["",0],["node",3]],["bool",0]],[[]],[[["usize",0]]],[[]],null,[[["",0]],["usize",0]],[[["",0]],["usize",0]],null,null,[[["",0]],["usize",0]],[[["",0]],["usize",0]],null,null,null,[[["",0],["leaf",3]]],[[["",0],["bool",0]]],[[["",0],["bool",0]],["result",4,[["str",0]]]],[[["",0],["bool",0]]],[[["",0],["bool",0],["usize",0]],["usize",0]],[[["",0],["bool",0],["usize",0]],["usize",0]],null,[[["",0],["usize",0],["usize",0]]],[[["",0],["usize",0]]],[[["",0],["isize",0],["isize",0]]],[[["",0],["usize",0],["i8",0]]],null,null,[[["",0],["usize",0],["usize",0]]],[[["",0],["usize",0],["usize",0]],["usize",0]],[[["",0],["bool",0],["usize",0]],["usize",0]],[[["",0],["bool",0],["usize",0]],["usize",0]],[[["",0],["isize",0]],["usize",0]],[[["",0]],["leafvalue",6]],[[["",0]],["leafvalue",6]],[[["",0],["isize",0]]],[[["",0],["usize",0]]],[[["",0]]],[[["",0]]],[[["",0]]],[[["",0]],["string",3]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[["",0]],["typeid",3]],[[["",0]],["typeid",3]],[[["",0]],["typeid",3]],[[["",0],["usize",0],["isize",0]]],null,[[["",0]]],[[["",0]]],null,null,null,null,null,null,[[["",0],["usize",0]],["bool",0]],[[["",0]],["usize",0]],[[["",0]],["usize",0]],[[["",0]],["usize",0]],[[["usize",0],["usize",0]]],[[["",0],["usize",0]],["result",4,[["str",0]]]],[[["usize",0]]],[[["",0],["isize",0]],["string",3]],[[["",0],["usize",0]]],[[["",0],["usize",0],["bool",0]],["result",4,[["str",0]]]],[[["usize",0],["usize",0],["bool",0]]],[[["",0]],["bool",0]],[[["",0]],["usize",0]],[[["",0]],["usize",0]],[[["",0]],["usize",0]],[[["usize",0]]],[[["",0],["bool",0],["usize",0]],["usize",0]],[[["",0],["bool",0],["usize",0]],["usize",0]],[[["usize",0]]],[[["",0]]]],"p":[[3,"Config"],[3,"DynamicBitVector"],[3,"Leaf"],[3,"Node"],[8,"StaticBitVec"],[8,"BitSize"],[8,"DynBitTree"],[8,"DynBitVec"],[8,"Dot"]]},\
"either":{"doc":"The enum <code>Either</code> with variants <code>Left</code> and <code>Right</code> is a general …","t":[4,2,13,2,13,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,14,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,14,14,11,11,11,11,12,12],"n":["Either","Left","Left","Right","Right","all","any","as_mut","as_mut","as_mut","as_mut","as_mut","as_mut","as_mut","as_ref","as_ref","as_ref","as_ref","as_ref","as_ref","as_ref","borrow","borrow_mut","cause","clone","clone_from","clone_into","cmp","collect","consume","count","deref","deref_mut","description","either","either_into","either_with","eq","expect_left","expect_right","extend","factor_err","factor_first","factor_none","factor_ok","factor_second","fill_buf","find","find_map","flip","flush","fmt","fmt","fold","for_both","for_each","from","from","hash","into","into","into_inner","into_iter","into_iter","is_left","is_right","last","left","left_and_then","left_or","left_or_default","left_or_else","len","map","map_left","map_right","ne","next","next_back","nth","partial_cmp","partition","position","read","read_to_end","rfind","rfold","right","right_and_then","right_or","right_or_default","right_or_else","seek","size_hint","source","to_owned","to_string","try_from","try_into","try_left","try_right","type_id","unwrap_left","unwrap_right","write","0","0"],"q":["either","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","either::Either",""],"d":["The enum <code>Either</code> with variants <code>Left</code> and <code>Right</code> is a general …","","A value of type <code>L</code>.","","A value of type <code>R</code>.","","","","","","","","Convert <code>&amp;mut Either&lt;L, R&gt;</code> to <code>Either&lt;&amp;mut L, &amp;mut R&gt;</code>.","","","","","","","Convert <code>&amp;Either&lt;L, R&gt;</code> to <code>Either&lt;&amp;L, &amp;R&gt;</code>.","","","","","","","","","","","","","","","Apply one of two functions depending on contents, unifying …","Convert the contained value into <code>T</code>","Like <code>either</code>, but provide some context to whichever of the …","","Returns the left value","Returns the right value","","Factors out a homogenous type from an <code>Either</code> of <code>Result</code>.","Factor out a homogeneous type from an either of pairs.","Factors out <code>None</code> from an <code>Either</code> of <code>Option</code>.","Factors out a homogenous type from an <code>Either</code> of <code>Result</code>.","Factor out a homogeneous type from an either of pairs.","","","","Convert <code>Either&lt;L, R&gt;</code> to <code>Either&lt;R, L&gt;</code>.","","","","","Evaluate the provided expression for both <code>Either::Left</code> and …","","Returns the argument unchanged.","","","Calls <code>U::from(self)</code>.","","Extract the value of an either over two equivalent types.","","Convert the inner value to an iterator.","Return true if the value is the <code>Left</code> variant.","Return true if the value is the <code>Right</code> variant.","","Convert the left side of <code>Either&lt;L, R&gt;</code> to an <code>Option&lt;L&gt;</code>.","Apply the function <code>f</code> on the value in the <code>Left</code> variant if …","Return left value or given value","Return left or a default","Returns left value or computes it from a closure","","Map <code>f</code> over the contained value and return the result in the","Apply the function <code>f</code> on the value in the <code>Left</code> variant if …","Apply the function <code>f</code> on the value in the <code>Right</code> variant if …","","","","","","","","","","","","Convert the right side of <code>Either&lt;L, R&gt;</code> to an <code>Option&lt;R&gt;</code>.","Apply the function <code>f</code> on the value in the <code>Right</code> variant if …","Return right value or given value","Return right or a default","Returns right value or computes it from a closure","","","","","","","","Macro for unwrapping the left side of an <code>Either</code>, which …","Dual to <code>try_left!</code>, see its documentation for more …","","Returns the left value","Returns the right value","","",""],"i":[0,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,2,3],"f":[null,null,null,null,null,[[["",0]],["bool",0]],[[["",0]],["bool",0]],[[["",0]],["str",0]],[[["",0]],["cstr",6]],[[["",0]],["osstr",3]],[[["",0]],["",0]],[[["",0]]],[[["",0]],["either",4]],[[["",0]],["path",3]],[[["",0]]],[[["",0]],["path",3]],[[["",0]],["",0]],[[["",0]],["str",0]],[[["",0]],["osstr",3]],[[["",0]],["either",4]],[[["",0]],["cstr",6]],[[["",0]],["",0]],[[["",0]],["",0]],[[["",0]],["option",4,[["error",8]]]],[[["",0]]],[[["",0],["",0]]],[[["",0],["",0]]],[[["",0],["either",4]],["ordering",4]],[[]],[[["",0],["usize",0]]],[[],["usize",0]],[[["",0]]],[[["",0]]],[[["",0]],["str",0]],[[]],[[]],[[]],[[["",0],["either",4]],["bool",0]],[[["str",0]]],[[["str",0]]],[[["",0]]],[[],["result",4,[["either",4]]]],[[]],[[],["option",4,[["either",4]]]],[[],["result",4,[["either",4]]]],[[]],[[["",0]],["result",6]],[[["",0]],["option",4]],[[["",0]],["option",4]],[[],["either",4]],[[["",0]],["result",6]],[[["",0],["formatter",3]],["result",6]],[[["",0],["formatter",3]],["result",6]],[[]],null,[[]],[[]],[[["result",4]]],[[["",0],["",0]]],[[]],[[],["result",4]],[[]],[[]],[[],["either",4]],[[["",0]],["bool",0]],[[["",0]],["bool",0]],[[],["option",4]],[[],["option",4]],[[],["either",4]],[[]],[[]],[[]],[[["",0]],["usize",0]],[[],["either",4]],[[],["either",4]],[[],["either",4]],[[["",0],["either",4]],["bool",0]],[[["",0]],["option",4]],[[["",0]],["option",4]],[[["",0],["usize",0]],["option",4]],[[["",0],["either",4]],["option",4,[["ordering",4]]]],[[]],[[["",0]],["option",4,[["usize",0]]]],[[["",0]],["result",6,[["usize",0]]]],[[["",0],["vec",3]],["result",6,[["usize",0]]]],[[["",0]],["option",4]],[[]],[[],["option",4]],[[],["either",4]],[[]],[[]],[[]],[[["",0],["seekfrom",4]],["result",6,[["u64",0]]]],[[["",0]]],[[["",0]],["option",4,[["error",8]]]],[[["",0]]],[[["",0]],["string",3]],[[],["result",4]],[[],["result",4]],null,null,[[["",0]],["typeid",3]],[[]],[[]],[[["",0]],["result",6,[["usize",0]]]],null,null],"p":[[4,"Either"],[13,"Left"],[13,"Right"]]}\
}');
if (window.initSearch) {window.initSearch(searchIndex)};